#!/usr/bin/env bash
set -euo pipefail

_script_dir() {
  local src="${BASH_SOURCE[0]}"
  while [ -L "$src" ]; do
    local dir
    dir="$(cd -P "$(dirname "$src")" && pwd)"
    src="$(readlink "$src")"
    [[ "$src" != /* ]] && src="$dir/$src"
  done
  cd -P "$(dirname "$src")" && pwd
}

RALPH_HOME="${RALPH_HOME:-$(_script_dir)}"
RALPH_LANG="${RALPH_LANG:-pl}"

case "$RALPH_LANG" in
  pl)
    MSG_GIT_ONLY="To polecenie dziala tylko w repo git."
    MSG_USAGE_RESTART="blad: podaj PID. Uzycie: ralph restart <pid>"
    MSG_BAD_PID="blad: nieprawidlowy PID:"
    MSG_STOP_REMOVED="usunieto stop, mozesz ponownie ustawic powtarzajac komende"
    MSG_STOP_SET="ustawiono stop"
    MSG_SAFE_STOP_REMOVED="usunieto safe-stop"
    MSG_SAFE_STOP_SET="ustawiono safe-stop"
    MSG_RESTART_PLANNED="restart zaplanowany: przeladuje sie po biezacym runie"
    MSG_RESTART_WRONG_PID="blad: aktywny PID dla tego repo to"
    MSG_RESTART_NO_PROCESS="blad: brak aktywnego procesu ralph run w tym repo"
    MSG_ALREADY_RUNNING="blad: ralph juz dziala. Uzyj: ralph restart"
    MSG_CODEX_NOT_FOUND="codex nie znaleziony w PATH"
    MSG_PROMPT_NOT_FOUND="Prompt nie znaleziony:"
    MSG_BAD_MODE="Nieznany RALPH_MODE (dozwolone: loop, single):"
    MSG_STARTED="uruchomiono"
    MSG_STOPPED="Ralph zatrzymany."
    MSG_RUN_DONE="run zakonczony"
    MSG_IDLE="idle"
    MSG_NEEDS_DECISION="wymaga decyzji (auto-continue)"
    MSG_TASK_DONE="task wykonany"
    MSG_ERROR="blad"
    MSG_SINGLE_STOPPED="zatrzymano: tryb single"
    MSG_RESTART_RELOAD="restart: przeladowanie w tym terminalu"
    MSG_NO_TASKS_PATTERN='BRAK ZADA[ŃN]'
    MSG_UNKNOWN_CMD="Nieznana komenda:"
    MSG_IDLE_PAUSE="przerwa"
    MSG_NO_TASKS_WAIT="brak nowych, czekam"
    MSG_NO_TASKS_WAIT_SUFFIX=""
    MSG_DECISION_CONTINUE="agent poprosil o decyzje, kontynuuje automatycznie"
    MSG_FAILED="FAILED"
    MSG_WT_HEADER="# Kontekst Working Tree (zastany przed runem)"
    MSG_WT_INFO="Ponizsze zmiany sa znane i dozwolone. Nie traktuj ich jako blokady."
    MSG_WT_SKIP="Nie pytaj o decyzje z powodu tych plikow; po prostu je ignoruj i kontynuuj."
    MSG_WT_LIST="Lista zastanych zmian:"
    MSG_WT_NONE="Lista zastanych zmian: (brak)"
    MSG_SHORT_TODO_LABEL="linie"
    MSG_SHORT_TODO_WAIT="czekam"
    MSG_HELP="Uzycie:
  ralph run            - uruchom petle agenta
  ralph restart <pid>  - przeladuj aktywny proces (po PID)
  ralph stop           - przelacz stop (ustaw/usun tasks/agent.stop)
  ralph safe-stop      - przelacz safe-stop (ustaw/usun tasks/agent.safe-stop)
  ralph help           - pokaz to menu

Zmienne srodowiskowe:
  RALPH_LANG    Jezyk: pl (domyslnie), en
  RALPH_MODE    Tryb: loop (domyslnie), single
  MODEL         Model AI (domyslnie: gpt-5.3-codex)
  REASONING     Poziom rozumowania (domyslnie: auto -> medium; auto|none|minimal|low|medium|high|xhigh)
  SLEEP_SECONDS Przerwa miedzy runami (domyslnie: 10)
  IDLE_SLEEP_SECONDS Przerwa przy braku zadan (domyslnie: 100)
  ERROR_SLEEP_SECONDS Przerwa po bledzie runa (domyslnie: 300)
  TODO_MIN_LINES_FOR_MODEL Minimalna liczba linii TODO.md do uruchomienia modelu (domyslnie: 10)
  RALPH_INLINE_CLAUDE    1 = dolacz cala tresc CLAUDE.md do promptu (domyslnie: 0)
  RALPH_WT_MAX_LINES     Limit linii git status dopinanych do promptu (domyslnie: 40)
  RALPH_GIT_SYNC_ON_START 1 = git pull --rebase raz na start sesji (domyslnie: 1)
  RALPH_GIT_PUSH_ON_IDLE  1 = push zaleglych commitow przy idle/stop (domyslnie: 1)
  STUCK_TIMEOUT_SECONDS  Timeout pojedynczej proby agenta (domyslnie: 1800)
  STUCK_KILL_GRACE_SECONDS  Czas do wymuszenia kill po timeout (domyslnie: 20)
  MAX_RETRIES_ON_FAILURE Retry po bledzie retryowalnym (domyslnie: 1)
  BACKOFF_MULTIPLIER     Mnoznik backoff retry (domyslnie: 2)
  RUN_BUDGET_WINDOW_SECONDS Okno budzetu runow (domyslnie: 3600)
  MAX_RUNS_PER_WINDOW    Maks runow w oknie (domyslnie: 30)
  RALPH_HOME    Katalog instalacji Ralph (auto-wykrywany)"
    ;;
  en)
    MSG_GIT_ONLY="This command only works inside a git repo."
    MSG_USAGE_RESTART="error: provide PID. Usage: ralph restart <pid>"
    MSG_BAD_PID="error: invalid PID:"
    MSG_STOP_REMOVED="stop removed, repeat command to set again"
    MSG_STOP_SET="stop set"
    MSG_SAFE_STOP_REMOVED="safe-stop removed"
    MSG_SAFE_STOP_SET="safe-stop set"
    MSG_RESTART_PLANNED="restart scheduled: will reload after current run"
    MSG_RESTART_WRONG_PID="error: active PID for this repo is"
    MSG_RESTART_NO_PROCESS="error: no active ralph run process in this repo"
    MSG_ALREADY_RUNNING="error: ralph already running. Use: ralph restart"
    MSG_CODEX_NOT_FOUND="codex not found in PATH"
    MSG_PROMPT_NOT_FOUND="Prompt not found:"
    MSG_BAD_MODE="Unknown RALPH_MODE (allowed: loop, single):"
    MSG_STARTED="started"
    MSG_STOPPED="Ralph stopped."
    MSG_RUN_DONE="run finished"
    MSG_IDLE="idle"
    MSG_NEEDS_DECISION="needs decision (auto-continue)"
    MSG_TASK_DONE="task completed"
    MSG_ERROR="error"
    MSG_SINGLE_STOPPED="stopped: single mode"
    MSG_RESTART_RELOAD="restart: reloading in this terminal"
    MSG_NO_TASKS_PATTERN='NO TASKS'
    MSG_UNKNOWN_CMD="Unknown command:"
    MSG_IDLE_PAUSE="pause"
    MSG_NO_TASKS_WAIT="finished: no open tasks, waiting"
    MSG_NO_TASKS_WAIT_SUFFIX="for new tasks"
    MSG_DECISION_CONTINUE="agent asked for decision, continuing automatically"
    MSG_FAILED="FAILED"
    MSG_WT_HEADER="# Working Tree Context (state before run)"
    MSG_WT_INFO="The changes below are known and allowed. Do not treat them as blockers."
    MSG_WT_SKIP="Do not ask for decisions about these files; just ignore them and continue."
    MSG_WT_LIST="Existing changes:"
    MSG_WT_NONE="Existing changes: (none)"
    MSG_SHORT_TODO_LABEL="lines"
    MSG_SHORT_TODO_WAIT="waiting"
    MSG_HELP="Usage:
  ralph run            - start agent loop
  ralph restart <pid>  - reload active process (by PID)
  ralph stop           - toggle stop (set/remove tasks/agent.stop)
  ralph safe-stop      - toggle safe-stop (set/remove tasks/agent.safe-stop)
  ralph help           - show this menu

Environment:
  RALPH_LANG    Language: pl (default), en
  RALPH_MODE    Mode: loop (default), single
  MODEL         AI model (default: gpt-5.3-codex)
  REASONING     Reasoning effort (default: auto -> medium; auto|none|minimal|low|medium|high|xhigh)
  SLEEP_SECONDS Sleep between runs (default: 10)
  IDLE_SLEEP_SECONDS Sleep while idle (default: 100)
  ERROR_SLEEP_SECONDS Sleep after failed run (default: 300)
  TODO_MIN_LINES_FOR_MODEL Minimum TODO.md lines required to run model (default: 10)
  RALPH_INLINE_CLAUDE    1 = inline full CLAUDE.md into prompt (default: 0)
  RALPH_WT_MAX_LINES     Max git status lines appended to prompt (default: 40)
  RALPH_GIT_SYNC_ON_START 1 = git pull --rebase once at session start (default: 1)
  RALPH_GIT_PUSH_ON_IDLE  1 = push pending commits on idle/stop (default: 1)
  STUCK_TIMEOUT_SECONDS  Timeout for a single agent attempt (default: 1800)
  STUCK_KILL_GRACE_SECONDS  Grace period before hard kill after timeout (default: 20)
  MAX_RETRIES_ON_FAILURE Retry attempts for retryable failures (default: 1)
  BACKOFF_MULTIPLIER     Backoff multiplier for retries (default: 2)
  RUN_BUDGET_WINDOW_SECONDS Run budget window in seconds (default: 3600)
  MAX_RUNS_PER_WINDOW    Max runs allowed per budget window (default: 30)
  RALPH_HOME    Ralph installation directory (auto-detected)"
    ;;
  *)
    echo "Unknown RALPH_LANG: $RALPH_LANG (allowed: pl, en)" >&2
    exit 2
    ;;
esac

ROOT_DIR="$(git rev-parse --show-toplevel 2>/dev/null)" || {
  echo "$MSG_GIT_ONLY"
  exit 1
}
TASKS_DIR="$ROOT_DIR/tasks"
TODO_FILE="$TASKS_DIR/TODO.md"
DONE_FILE="$TASKS_DIR/DONE.md"
TODO_ARCHIVE_FILE="$TASKS_DIR/TODO_ARCHIVE.md"
STOP_FILE="$TASKS_DIR/agent.stop"
SAFE_STOP_FILE="$TASKS_DIR/agent.safe-stop"
RESTART_FILE="$TASKS_DIR/agent.restart"
LOG_DIR="$TASKS_DIR/logs"
RUNS_DIR="$LOG_DIR/runs"
PID_FILE="$LOG_DIR/ralph.pid"
RUN_BUDGET_STATE_FILE="$LOG_DIR/run_budget_state.json"

MODEL="${MODEL:-gpt-5.3-codex}"
REASONING_INPUT="${REASONING:-auto}"
REASONING_REQUESTED="$(printf '%s' "$REASONING_INPUT" | tr '[:upper:]' '[:lower:]')"
SLEEP_SECONDS="${SLEEP_SECONDS:-10}"
IDLE_SLEEP_SECONDS="${IDLE_SLEEP_SECONDS:-100}"
ERROR_SLEEP_SECONDS="${ERROR_SLEEP_SECONDS:-300}"
TODO_MIN_LINES_FOR_MODEL="${TODO_MIN_LINES_FOR_MODEL:-10}"
RALPH_VERBOSE="${RALPH_VERBOSE:-0}"
RALPH_MODE="${RALPH_MODE:-loop}"
BASE_PROMPT_FILE="${BASE_PROMPT_FILE:-$RALPH_HOME/prompts/${RALPH_LANG}.md}"
RALPH_INLINE_CLAUDE="${RALPH_INLINE_CLAUDE:-0}"
RALPH_WT_MAX_LINES="${RALPH_WT_MAX_LINES:-40}"
RALPH_GIT_SYNC_ON_START="${RALPH_GIT_SYNC_ON_START:-1}"
RALPH_GIT_PUSH_ON_IDLE="${RALPH_GIT_PUSH_ON_IDLE:-1}"
STUCK_TIMEOUT_SECONDS="${STUCK_TIMEOUT_SECONDS:-1800}"
STUCK_KILL_GRACE_SECONDS="${STUCK_KILL_GRACE_SECONDS:-20}"
MAX_RETRIES_ON_FAILURE="${MAX_RETRIES_ON_FAILURE:-1}"
BACKOFF_MULTIPLIER="${BACKOFF_MULTIPLIER:-2}"
RUN_BUDGET_WINDOW_SECONDS="${RUN_BUDGET_WINDOW_SECONDS:-3600}"
MAX_RUNS_PER_WINDOW="${MAX_RUNS_PER_WINDOW:-30}"

if [[ ! "$RALPH_WT_MAX_LINES" =~ ^[0-9]+$ ]]; then
  RALPH_WT_MAX_LINES="40"
fi
if [[ ! "$TODO_MIN_LINES_FOR_MODEL" =~ ^[0-9]+$ ]]; then
  TODO_MIN_LINES_FOR_MODEL="10"
fi
if [[ ! "$STUCK_TIMEOUT_SECONDS" =~ ^[0-9]+$ ]]; then
  STUCK_TIMEOUT_SECONDS="1800"
fi
if [[ ! "$STUCK_KILL_GRACE_SECONDS" =~ ^[0-9]+$ ]]; then
  STUCK_KILL_GRACE_SECONDS="20"
fi
if [[ ! "$MAX_RETRIES_ON_FAILURE" =~ ^[0-9]+$ ]]; then
  MAX_RETRIES_ON_FAILURE="1"
fi
if [[ ! "$BACKOFF_MULTIPLIER" =~ ^[0-9]+$ ]] || [[ "$BACKOFF_MULTIPLIER" -lt 1 ]]; then
  BACKOFF_MULTIPLIER="2"
fi
if [[ ! "$RUN_BUDGET_WINDOW_SECONDS" =~ ^[0-9]+$ ]]; then
  RUN_BUDGET_WINDOW_SECONDS="3600"
fi
if [[ ! "$MAX_RUNS_PER_WINDOW" =~ ^[0-9]+$ ]]; then
  MAX_RUNS_PER_WINDOW="30"
fi

COMMAND="${1:-help}"
case "$COMMAND" in
  run)
    ;;
  restart)
    target_pid="${2:-}"
    if [[ -z "$target_pid" ]]; then
      echo "$MSG_USAGE_RESTART"
      exit 2
    fi
    if [[ ! "$target_pid" =~ ^[0-9]+$ ]]; then
      echo "$MSG_BAD_PID $target_pid"
      exit 2
    fi

    mkdir -p "$TASKS_DIR" "$RUNS_DIR"
    if [[ -f "$STOP_FILE" ]]; then
      rm -f "$STOP_FILE"
      echo "$MSG_STOP_REMOVED"
    fi

    active_pid=""
    if [[ -f "$PID_FILE" ]]; then
      pid_from_file="$(cat "$PID_FILE" 2>/dev/null || true)"
      if [[ -n "$pid_from_file" ]] && kill -0 "$pid_from_file" 2>/dev/null; then
        active_pid="$pid_from_file"
      fi
    fi

    if [[ -n "$active_pid" ]]; then
      if [[ "$active_pid" != "$target_pid" ]]; then
        echo "$MSG_RESTART_WRONG_PID $active_pid (given: $target_pid)"
        exit 1
      fi
      printf '%s\n' "$target_pid" > "$RESTART_FILE"
      echo "$MSG_RESTART_PLANNED (pid=$target_pid)"
      exit 0
    fi

    echo "$MSG_RESTART_NO_PROCESS"
    exit 1
    ;;
  stop)
    if [[ -f "$STOP_FILE" ]]; then
      rm -f "$STOP_FILE"
      echo "$MSG_STOP_REMOVED"
    else
      mkdir -p "$TASKS_DIR"
      touch "$STOP_FILE"
      echo "$MSG_STOP_SET: $STOP_FILE"
    fi
    exit 0
    ;;
  safe-stop)
    if [[ -f "$SAFE_STOP_FILE" ]]; then
      rm -f "$SAFE_STOP_FILE"
      echo "$MSG_SAFE_STOP_REMOVED"
    else
      mkdir -p "$TASKS_DIR"
      touch "$SAFE_STOP_FILE"
      echo "$MSG_SAFE_STOP_SET: $SAFE_STOP_FILE"
    fi
    exit 0
    ;;
  help|--help|-h)
    echo "$MSG_HELP"
    exit 0
    ;;
  *)
    echo "$MSG_UNKNOWN_CMD $COMMAND"
    echo "Usage: ralph [run|restart <pid>|stop|safe-stop|help]"
    exit 2
    ;;
esac

mkdir -p "$TASKS_DIR" "$RUNS_DIR"
if [[ ! -f "$TODO_FILE" ]]; then
  if [[ -f "$ROOT_DIR/docs/TODO.md" ]]; then
    cp "$ROOT_DIR/docs/TODO.md" "$TODO_FILE"
  else
    printf '# TODO\n\n' > "$TODO_FILE"
  fi
fi
if [[ ! -f "$DONE_FILE" ]]; then
  if [[ -f "$ROOT_DIR/docs/DONE.md" ]]; then
    cp "$ROOT_DIR/docs/DONE.md" "$DONE_FILE"
  else
    printf '# DONE\n\n' > "$DONE_FILE"
  fi
fi
if [[ ! -f "$TODO_ARCHIVE_FILE" ]]; then
  if [[ -f "$ROOT_DIR/docs/TODO_ARCHIVE.md" ]]; then
    cp "$ROOT_DIR/docs/TODO_ARCHIVE.md" "$TODO_ARCHIVE_FILE"
  else
    printf '# TODO Archive\n\n' > "$TODO_ARCHIVE_FILE"
  fi
fi

command -v codex >/dev/null || {
  echo "$MSG_CODEX_NOT_FOUND"
  exit 1
}
HAS_TIMEOUT=0
if command -v timeout >/dev/null 2>&1; then
  HAS_TIMEOUT=1
fi
COMMIT_POLICY_SCRIPT="$RALPH_HOME/scripts/validate_commit_policy.sh"
REPORT_RUNS_SCRIPT="$RALPH_HOME/scripts/report_runs.sh"
[[ -f "$BASE_PROMPT_FILE" ]] || {
  echo "$MSG_PROMPT_NOT_FOUND $BASE_PROMPT_FILE"
  exit 1
}
if [[ "$RALPH_MODE" != "single" && "$RALPH_MODE" != "loop" ]]; then
  echo "$MSG_BAD_MODE $RALPH_MODE" >&2
  exit 1
fi

is_allowed_reasoning() {
  case "$1" in
    auto|none|minimal|low|medium|high|xhigh) return 0 ;;
    *) return 1 ;;
  esac
}

if ! is_allowed_reasoning "$REASONING_REQUESTED"; then
  echo "Invalid REASONING: $REASONING_INPUT (allowed: auto, none, minimal, low, medium, high, xhigh)" >&2
  exit 2
fi

file_hash() {
  local path="$1"
  if [[ -f "$path" ]]; then
    sha256sum "$path" | awk '{print $1}'
  else
    echo "-"
  fi
}

echo "$MSG_STARTED: repo=$(basename "$ROOT_DIR"), pid=$$, mode=$RALPH_MODE, logs=$LOG_DIR, stop=$STOP_FILE"

notify() {
  notify-send -u "$1" "Ralph [$(basename "$ROOT_DIR")]" "$2" 2>/dev/null || true
}

cleanup_pid_file() {
  if [[ -f "$PID_FILE" ]]; then
    local pid
    pid="$(cat "$PID_FILE" 2>/dev/null || true)"
    if [[ "$pid" == "$$" ]]; then
      rm -f "$PID_FILE"
    fi
  fi
}

restart_self_if_requested() {
  if [[ -f "$RESTART_FILE" ]]; then
    requested_pid="$(head -n 1 "$RESTART_FILE" 2>/dev/null || true)"
    if [[ -z "$requested_pid" ]]; then
      rm -f "$RESTART_FILE"
      return
    fi

    if [[ "$requested_pid" != "$$" ]]; then
      if ! kill -0 "$requested_pid" 2>/dev/null; then
        rm -f "$RESTART_FILE"
      fi
      return
    fi

    rm -f "$RESTART_FILE"
    rm -f "$STOP_FILE"
    echo "$MSG_RESTART_RELOAD (pid=$requested_pid)"
    exec "$0" run
  fi
}

if [[ -f "$PID_FILE" ]]; then
  existing_pid="$(cat "$PID_FILE" 2>/dev/null || true)"
  if [[ -n "$existing_pid" && "$existing_pid" != "$$" ]] && kill -0 "$existing_pid" 2>/dev/null; then
    echo "$MSG_ALREADY_RUNNING (pid=$existing_pid)"
    exit 1
  fi
fi
echo "$$" > "$PID_FILE"
trap cleanup_pid_file EXIT

sleep_with_dots() {
  local total="$1"
  local step=5
  local elapsed=0

  if [[ "$total" -le 0 ]]; then
    return 0
  fi

  while [[ "$elapsed" -lt "$total" ]]; do
    local chunk="$step"
    if [[ $((total - elapsed)) -lt "$step" ]]; then
      chunk=$((total - elapsed))
    fi
    sleep "$chunk"
    elapsed=$((elapsed + chunk))
    echo -n "."
  done
  echo
}

todo_line_count() {
  if [[ ! -f "$TODO_FILE" ]]; then
    echo "0"
    return
  fi

  local lines
  lines="$(wc -l < "$TODO_FILE" | tr -d '[:space:]')"
  if [[ "$lines" =~ ^[0-9]+$ ]]; then
    echo "$lines"
  else
    echo "0"
  fi
}

first_open_task_excerpt() {
  [[ -f "$TODO_FILE" ]] || return 0
  awk '
    BEGIN { capture=0; lines=0 }
    /^## / {
      if (capture) { exit }
      if ($0 ~ /DONE/) { next }
      capture=1
    }
    capture {
      print
      lines++
      if (lines >= 120) { exit }
    }
  ' "$TODO_FILE"
}

infra_failure_signature() {
  local log_file="$1"
  local matches
  [[ -f "$log_file" ]] || return 1
  matches="$(grep -Eio 'ETIMEDOUT|ECONNRESET|EAI_AGAIN|ENOTFOUND|connection refused|temporarily unavailable|timed out|timeout|rate limit|429|5[0-9]{2}|unable to access|could not resolve host|certificate|TLS|network|service unavailable' "$log_file" || true)"
  [[ -n "$matches" ]] || return 1
  printf '%s\n' "$matches" | head -n 1 | tr '[:upper:]' '[:lower:]'
}

repeated_infra_failure_signature() {
  local recent_completed_runs=()
  local run_dir
  local meta_file
  local exit_code_1
  local exit_code_2
  local sig_1
  local sig_2

  while IFS= read -r run_dir; do
    [[ -d "$run_dir" ]] || continue
    meta_file="$run_dir/meta.txt"
    [[ -f "$meta_file" ]] || continue
    if grep -q '^exit_code=' "$meta_file"; then
      recent_completed_runs+=("$run_dir")
      if [[ "${#recent_completed_runs[@]}" -ge 2 ]]; then
        break
      fi
    fi
  done < <(ls -1dt "$RUNS_DIR"/* 2>/dev/null || true)

  [[ "${#recent_completed_runs[@]}" -ge 2 ]] || return 1

  exit_code_1="$(grep -E '^exit_code=' "${recent_completed_runs[0]}/meta.txt" | tail -n 1 | cut -d= -f2 || true)"
  exit_code_2="$(grep -E '^exit_code=' "${recent_completed_runs[1]}/meta.txt" | tail -n 1 | cut -d= -f2 || true)"

  [[ "$exit_code_1" =~ ^[0-9]+$ ]] || return 1
  [[ "$exit_code_2" =~ ^[0-9]+$ ]] || return 1
  [[ "$exit_code_1" -ne 0 && "$exit_code_2" -ne 0 ]] || return 1

  sig_1="$(infra_failure_signature "${recent_completed_runs[0]}/stdout.log" || true)"
  sig_2="$(infra_failure_signature "${recent_completed_runs[1]}/stdout.log" || true)"
  [[ -n "$sig_1" && -n "$sig_2" && "$sig_1" == "$sig_2" ]] || return 1

  printf '%s\n' "$sig_1"
}

REASONING_SELECTED=""
REASONING_REASON=""
select_reasoning() {
  local task_excerpt
  local repeated_sig

  if [[ "$REASONING_REQUESTED" != "auto" ]]; then
    REASONING_SELECTED="$REASONING_REQUESTED"
    REASONING_REASON="manual override"
    return 0
  fi

  if repeated_sig="$(repeated_infra_failure_signature)"; then
    REASONING_SELECTED="xhigh"
    REASONING_REASON="repeated infra failure: ${repeated_sig}"
    return 0
  fi

  task_excerpt="$(first_open_task_excerpt)"
  if [[ -n "$task_excerpt" ]] && printf '%s\n' "$task_excerpt" | grep -Eqi 'migrac|migration|routing|bootstrap|security|auth|authorization|authentication|csrf|xss|sql injection|schema|cross[- ]cutting|przekrojow|bezpieczenstw'; then
    REASONING_SELECTED="high"
    REASONING_REASON="migration/security/cross-cutting task"
    return 0
  fi
  if [[ -n "$task_excerpt" ]] && printf '%s\n' "$task_excerpt" | grep -Eqi 'readme|documentation|dokumentac|changelog|todo|done\.md|housekeeping|cleanup|formatting|lint|typo|komentarz|comment'; then
    REASONING_SELECTED="low"
    REASONING_REASON="docs/admin task"
    return 0
  fi

  REASONING_SELECTED="medium"
  REASONING_REASON="default auto heuristic"
}

read_meta_value() {
  local key="$1"
  local file="$2"
  [[ -f "$file" ]] || return 1
  grep -E "^${key}=" "$file" | tail -n 1 | cut -d= -f2- || true
}

previous_run_meta_value() {
  local key="$1"
  local current_run_dir="$2"
  local run_dir
  local value=""

  while IFS= read -r run_dir; do
    [[ -d "$run_dir" ]] || continue
    [[ "$run_dir" == "$current_run_dir" ]] && continue
    value="$(read_meta_value "$key" "$run_dir/meta.txt")"
    if [[ -n "$value" ]]; then
      printf '%s\n' "$value"
      return 0
    fi
  done < <(ls -1dt "$RUNS_DIR"/* 2>/dev/null || true)
  return 1
}

build_context_hash() {
  local file
  if [[ "$#" -eq 0 ]]; then
    echo "none"
    return 0
  fi
  {
    for file in "$@"; do
      printf '%s\0' "$file"
      sha256sum "$file" 2>/dev/null || true
    done
  } | sha256sum | awk '{print $1}'
}

save_run_budget_state() {
  local entries=("$@")
  local i
  local total="${#entries[@]}"

  {
    echo "{"
    echo "  \"run_starts\": ["
    for ((i = 0; i < total; i++)); do
      if [[ "$i" -lt $((total - 1)) ]]; then
        printf '    %s,\n' "${entries[$i]}"
      else
        printf '    %s\n' "${entries[$i]}"
      fi
    done
    echo "  ]"
    echo "}"
  } > "$RUN_BUDGET_STATE_FILE"
}

load_run_budget_state() {
  [[ -f "$RUN_BUDGET_STATE_FILE" ]] || return 0
  grep -Eo '[0-9]+' "$RUN_BUDGET_STATE_FILE" || true
}

RUN_BUDGET_USED=0
enforce_run_budget() {
  local now
  local cooldown
  local entries=()
  local kept=()
  local ts

  if [[ "$MAX_RUNS_PER_WINDOW" -le 0 || "$RUN_BUDGET_WINDOW_SECONDS" -le 0 ]]; then
    RUN_BUDGET_USED=0
    return 0
  fi

  while IFS= read -r ts; do
    [[ "$ts" =~ ^[0-9]+$ ]] && entries+=("$ts")
  done < <(load_run_budget_state)

  now="$(date +%s)"
  while true; do
    kept=()
    for ts in "${entries[@]}"; do
      if [[ $((now - ts)) -lt "$RUN_BUDGET_WINDOW_SECONDS" ]]; then
        kept+=("$ts")
      fi
    done
    entries=("${kept[@]}")

    if [[ "${#entries[@]}" -lt "$MAX_RUNS_PER_WINDOW" ]]; then
      break
    fi

    cooldown=$((RUN_BUDGET_WINDOW_SECONDS - (now - entries[0]) + 1))
    if [[ "$cooldown" -lt 1 ]]; then
      cooldown=1
    fi
    echo "[$(date +'%F %T')] budget: reached ${#entries[@]}/$MAX_RUNS_PER_WINDOW, cooldown ${cooldown}s"
    sleep_with_dots "$cooldown"
    now="$(date +%s)"
  done

  entries+=("$now")
  RUN_BUDGET_USED="${#entries[@]}"
  save_run_budget_state "${entries[@]}"
}

classify_failure() {
  local exit_code="$1"
  local log_file="$2"
  local stuck_timeout_hit="$3"
  local policy_violation="$4"

  if [[ "$policy_violation" == "1" ]]; then
    echo "policy_violation"
    return 0
  fi
  if [[ "$exit_code" -eq 0 ]]; then
    echo "none"
    return 0
  fi
  if [[ "$stuck_timeout_hit" == "1" ]]; then
    echo "stuck"
    return 0
  fi
  if infra_failure_signature "$log_file" >/dev/null 2>&1; then
    echo "infra_network"
    return 0
  fi
  if grep -Eqi 'lint|phpstan|eslint|flake8|pylint|style check|format check' "$log_file"; then
    echo "lint_failure"
    return 0
  fi
  if grep -Eqi 'tests? failed|test suite failed|assertion|FAILURES!|failing test|\\bFAILED\\b|\\bfail\\b' "$log_file"; then
    echo "test_failure"
    return 0
  fi
  echo "unknown"
}

is_retryable_failure() {
  case "$1" in
    infra_network|stuck) return 0 ;;
    *) return 1 ;;
  esac
}

compute_backoff_seconds() {
  local retry_index="$1"
  local out="$ERROR_SLEEP_SECONDS"
  local i=1

  while [[ "$i" -lt "$retry_index" ]]; do
    out=$((out * BACKOFF_MULTIPLIER))
    i=$((i + 1))
  done
  echo "$out"
}

trap 'echo "$MSG_STOPPED"; notify normal "$MSG_STOPPED"; exit 130' INT TERM

run_count=0
total_ok=0
total_fail=0

sync_pull_once() {
  [[ "$RALPH_GIT_SYNC_ON_START" == "1" ]] || return 0

  if [[ -z "$(git -C "$ROOT_DIR" remote 2>/dev/null)" ]]; then
    echo "[$(date +'%F %T')] sync: skip pull -- no git remote"
    return 0
  fi

  if ! git -C "$ROOT_DIR" diff --quiet || ! git -C "$ROOT_DIR" diff --cached --quiet; then
    echo "[$(date +'%F %T')] sync: skip pull -- dirty working tree"
    return 0
  fi

  if git -C "$ROOT_DIR" pull --rebase --quiet; then
    echo "[$(date +'%F %T')] sync: pull --rebase done"
  else
    echo "[$(date +'%F %T')] sync: pull --rebase failed (continuing)"
  fi
}

push_pending_commits() {
  [[ "$RALPH_GIT_PUSH_ON_IDLE" == "1" ]] || return 0

  if [[ -z "$(git -C "$ROOT_DIR" remote 2>/dev/null)" ]]; then
    return 0
  fi

  if ! git -C "$ROOT_DIR" rev-parse --abbrev-ref --symbolic-full-name '@{upstream}' >/dev/null 2>&1; then
    return 0
  fi

  local ahead
  ahead="$(git -C "$ROOT_DIR" rev-list --count '@{upstream}..HEAD' 2>/dev/null || echo 0)"
  if [[ ! "$ahead" =~ ^[0-9]+$ ]]; then
    ahead=0
  fi
  if [[ "$ahead" -eq 0 ]]; then
    return 0
  fi

  if git -C "$ROOT_DIR" push --quiet; then
    echo "[$(date +'%F %T')] sync: pushed $ahead commit(s)"
    return 0
  fi

  echo "[$(date +'%F %T')] sync: push failed, trying pull --rebase + push"
  if git -C "$ROOT_DIR" pull --rebase --quiet && git -C "$ROOT_DIR" push --quiet; then
    echo "[$(date +'%F %T')] sync: push recovered after rebase"
  else
    echo "[$(date +'%F %T')] sync: push failed (continuing)"
  fi
}

sync_pull_once

while true; do
  restart_self_if_requested
  [[ -f "$SAFE_STOP_FILE" ]] && {
    push_pending_commits
    echo "Safe-stop file detected."
    exit 0
  }
  [[ -f "$STOP_FILE" ]] && {
    push_pending_commits
    echo "Stop file detected."
    exit 0
  }

  todo_lines="$(todo_line_count)"
  if [[ "$todo_lines" -lt "$TODO_MIN_LINES_FOR_MODEL" ]]; then
    push_pending_commits
    echo -n "[$(date +'%F %T')] $MSG_SHORT_TODO_LABEL:$todo_lines < $TODO_MIN_LINES_FOR_MODEL, $MSG_SHORT_TODO_WAIT "
    sleep_with_dots "$IDLE_SLEEP_SECONDS"
    continue
  fi

  enforce_run_budget

  run_count=$((run_count + 1))
  ts="$(date +%Y%m%d-%H%M%S)"
  run_dir="$RUNS_DIR/$ts-$run_count"
  mkdir -p "$run_dir"
  log_file="$run_dir/stdout.log"

  ln -sfn "$run_dir" "$LOG_DIR/latest"

  select_reasoning
  reasoning_selected="$REASONING_SELECTED"
  reasoning_reason="$REASONING_REASON"
  if [[ "$REASONING_REQUESTED" == "auto" ]]; then
    reasoning_tag="reason=auto($reasoning_selected)"
  else
    reasoning_tag="reason=$reasoning_selected"
  fi

  echo "[$(date +'%F %T')] $MSG_STARTED run #$run_count ($reasoning_tag)"
  notify normal "Run #$run_count started"

  combined="$(mktemp)"
  context_files=()
  [[ -f "$HOME/.claude/CLAUDE.md" ]] && context_files+=("$HOME/.claude/CLAUDE.md")
  [[ -f "$RALPH_HOME/CLAUDE.md" ]] && context_files+=("$RALPH_HOME/CLAUDE.md")
  if [[ -f "$ROOT_DIR/CLAUDE.md" && "$ROOT_DIR/CLAUDE.md" != "$RALPH_HOME/CLAUDE.md" ]]; then
    context_files+=("$ROOT_DIR/CLAUDE.md")
  fi

  context_hash="$(build_context_hash "${context_files[@]}")"

  if [[ "$RALPH_INLINE_CLAUDE" == "1" ]]; then
    for context_file in "${context_files[@]}"; do
      cat "$context_file" >> "$combined"
      echo >> "$combined"
    done
  elif [[ ${#context_files[@]} -gt 0 ]]; then
    {
      echo "# Runtime context files"
      echo "Use these files as source of truth, but read only relevant fragments:"
      for context_file in "${context_files[@]}"; do
        echo "- $context_file"
      done
      echo
    } >> "$combined"
  fi

  baseline_all_status="$(git -C "$ROOT_DIR" status --short || true)"
  baseline_status="$(printf '%s\n' "$baseline_all_status" | head -n "$RALPH_WT_MAX_LINES" || true)"
  baseline_count=0
  if [[ -n "$baseline_all_status" ]]; then
    baseline_count="$(printf '%s\n' "$baseline_all_status" | wc -l | tr -d ' ')"
  fi
  {
    echo
    echo "$MSG_WT_HEADER"
    echo "$MSG_WT_INFO"
    echo "$MSG_WT_SKIP"
    if [[ -n "$baseline_status" ]]; then
      echo "$MSG_WT_LIST"
      printf '%s\n' "$baseline_status"
      if [[ "$baseline_count" -gt "$RALPH_WT_MAX_LINES" ]]; then
        echo "... (+$((baseline_count - RALPH_WT_MAX_LINES)) more)"
      fi
    else
      echo "$MSG_WT_NONE"
    fi
    echo
  } >> "$combined"
  cat "$BASE_PROMPT_FILE" >> "$combined"
  prompt_hash="$(file_hash "$combined")"
  previous_context_hash="$(previous_run_meta_value "context_hash" "$run_dir" || true)"
  previous_prompt_hash="$(previous_run_meta_value "prompt_hash" "$run_dir" || true)"
  prompt_drift="0"
  drift_reason="none"
  if [[ -n "$previous_context_hash" && "$previous_context_hash" != "$context_hash" ]]; then
    prompt_drift="1"
    drift_reason="context_changed"
  fi
  if [[ -n "$previous_prompt_hash" && "$previous_prompt_hash" != "$prompt_hash" ]]; then
    if [[ "$prompt_drift" == "0" ]]; then
      prompt_drift="1"
      drift_reason="prompt_changed"
    fi
  fi
  if [[ "$prompt_drift" == "1" ]]; then
    echo "[$(date +'%F %T')] warning: prompt drift detected ($drift_reason)"
  fi

  cp "$combined" "$run_dir/prompt.txt"
  {
    echo "run=$run_count"
    echo "started=$(date +'%F %T')"
    echo "model=$MODEL"
    echo "reasoning=$reasoning_selected"
    echo "reasoning_requested=$REASONING_INPUT"
    echo "reasoning_selected=$reasoning_selected"
    echo "reasoning_reason=$reasoning_reason"
    echo "run_budget_window_seconds=$RUN_BUDGET_WINDOW_SECONDS"
    echo "max_runs_per_window=$MAX_RUNS_PER_WINDOW"
    echo "run_budget_used=$RUN_BUDGET_USED"
    echo "context_hash=$context_hash"
    echo "prompt_hash=$prompt_hash"
    echo "prompt_drift=$prompt_drift"
    echo "drift_reason=$drift_reason"
    echo "root=$ROOT_DIR"
  } > "$run_dir/meta.txt"

  todo_before="$(file_hash "$TODO_FILE")"
  done_before="$(file_hash "$DONE_FILE")"
  archive_before="$(file_hash "$TODO_ARCHIVE_FILE")"
  head_before="$(git -C "$ROOT_DIR" rev-parse HEAD 2>/dev/null || true)"

  run_started_epoch="$(date +%s)"
  : > "$log_file"
  attempt=0
  retry_count=0
  stuck_timeout_hit=0
  failure_class="none"
  infra_sig="none"
  policy_violation=0

  set +e
  while true; do
    attempt=$((attempt + 1))
    echo "[$(date +'%F %T')] attempt=$attempt" >> "$log_file"

    if [[ "$RALPH_VERBOSE" == "1" ]]; then
      if [[ "$HAS_TIMEOUT" == "1" && "$STUCK_TIMEOUT_SECONDS" -gt 0 ]]; then
        timeout -k "${STUCK_KILL_GRACE_SECONDS}s" "${STUCK_TIMEOUT_SECONDS}s" \
          codex -a never -s workspace-write exec \
          -C "$ROOT_DIR" \
          -m "$MODEL" \
          -c model_reasoning_effort="$reasoning_selected" \
          "$(cat "$combined")" 2>&1 | tee -a "$log_file"
        exit_code=${PIPESTATUS[0]}
      else
        codex -a never -s workspace-write exec \
          -C "$ROOT_DIR" \
          -m "$MODEL" \
          -c model_reasoning_effort="$reasoning_selected" \
          "$(cat "$combined")" 2>&1 | tee -a "$log_file"
        exit_code=${PIPESTATUS[0]}
      fi
    else
      if [[ "$HAS_TIMEOUT" == "1" && "$STUCK_TIMEOUT_SECONDS" -gt 0 ]]; then
        timeout -k "${STUCK_KILL_GRACE_SECONDS}s" "${STUCK_TIMEOUT_SECONDS}s" \
          codex -a never -s workspace-write exec \
          -C "$ROOT_DIR" \
          -m "$MODEL" \
          -c model_reasoning_effort="$reasoning_selected" \
          "$(cat "$combined")" >> "$log_file" 2>&1
        exit_code=$?
      else
        codex -a never -s workspace-write exec \
          -C "$ROOT_DIR" \
          -m "$MODEL" \
          -c model_reasoning_effort="$reasoning_selected" \
          "$(cat "$combined")" >> "$log_file" 2>&1
        exit_code=$?
      fi
    fi

    attempt_stuck=0
    if [[ "$HAS_TIMEOUT" == "1" && "$STUCK_TIMEOUT_SECONDS" -gt 0 && "$exit_code" -eq 124 ]]; then
      attempt_stuck=1
      stuck_timeout_hit=1
    fi

    infra_sig="$(infra_failure_signature "$log_file" || true)"
    if [[ -z "$infra_sig" ]]; then
      infra_sig="none"
    fi
    failure_class="$(classify_failure "$exit_code" "$log_file" "$attempt_stuck" "0")"

    if [[ "$exit_code" -eq 0 ]]; then
      break
    fi
    if is_retryable_failure "$failure_class" && [[ "$retry_count" -lt "$MAX_RETRIES_ON_FAILURE" ]]; then
      retry_count=$((retry_count + 1))
      backoff_seconds="$(compute_backoff_seconds "$retry_count")"
      echo "[$(date +'%F %T')] retry: class=$failure_class, attempt=$retry_count/$MAX_RETRIES_ON_FAILURE, backoff=${backoff_seconds}s" | tee -a "$log_file"
      sleep_with_dots "$backoff_seconds"
      continue
    fi
    break
  done
  set -e
  run_finished_epoch="$(date +%s)"
  rm -f "$combined"

  head_after="$(git -C "$ROOT_DIR" rev-parse HEAD 2>/dev/null || true)"
  policy_reason="none"
  if [[ -x "$COMMIT_POLICY_SCRIPT" ]]; then
    if ! "$COMMIT_POLICY_SCRIPT" "$ROOT_DIR" "$head_before" "$head_after" > "$run_dir/policy_check.log" 2>&1; then
      policy_violation=1
      policy_reason="$(tail -n 1 "$run_dir/policy_check.log" | tr -d '\r' || true)"
      [[ -z "$policy_reason" ]] && policy_reason="policy_check_failed"
      touch "$SAFE_STOP_FILE"
    fi
  else
    policy_reason="script_unavailable"
  fi

  if [[ "$policy_violation" -eq 1 && "$exit_code" -eq 0 ]]; then
    exit_code=50
  fi

  failure_class="$(classify_failure "$exit_code" "$log_file" "$stuck_timeout_hit" "$policy_violation")"
  if [[ -z "$infra_sig" || "$infra_sig" == "none" ]]; then
    infra_sig="$(infra_failure_signature "$log_file" || true)"
    [[ -z "$infra_sig" ]] && infra_sig="none"
  fi

  test_seconds="$(grep -Eo 'RALPH_TEST_SECONDS=[0-9]+' "$log_file" | tail -n 1 | cut -d= -f2 || true)"
  if [[ -z "$test_seconds" ]]; then
    test_seconds="unknown"
  fi

  todo_after="$(file_hash "$TODO_FILE")"
  done_after="$(file_hash "$DONE_FILE")"
  archive_after="$(file_hash "$TODO_ARCHIVE_FILE")"

  stop_reason="none"
  stopped_by="none"
  if [[ "$stuck_timeout_hit" -eq 1 ]]; then
    stop_reason="stuck_timeout"
    stopped_by="watchdog"
    touch "$SAFE_STOP_FILE"
  elif [[ "$policy_violation" -eq 1 ]]; then
    stop_reason="policy_violation"
    stopped_by="watchdog"
  elif [[ -f "$SAFE_STOP_FILE" ]]; then
    stop_reason="safe_stop"
    stopped_by="operator"
  fi

  echo "exit_code=$exit_code" >> "$run_dir/meta.txt"
  echo "attempt_count=$attempt" >> "$run_dir/meta.txt"
  echo "retry_count=$retry_count" >> "$run_dir/meta.txt"
  echo "failure_class=$failure_class" >> "$run_dir/meta.txt"
  echo "infra_failure_signature=$infra_sig" >> "$run_dir/meta.txt"
  echo "policy_violation=$policy_violation" >> "$run_dir/meta.txt"
  echo "policy_reason=$policy_reason" >> "$run_dir/meta.txt"
  echo "stuck_timeout_hit=$stuck_timeout_hit" >> "$run_dir/meta.txt"
  echo "stop_reason=$stop_reason" >> "$run_dir/meta.txt"
  echo "stopped_by=$stopped_by" >> "$run_dir/meta.txt"
  echo "test_seconds=$test_seconds" >> "$run_dir/meta.txt"
  echo "duration_seconds=$((run_finished_epoch - run_started_epoch))" >> "$run_dir/meta.txt"
  echo "finished=$(date +'%F %T')" >> "$run_dir/meta.txt"
  if [[ -x "$REPORT_RUNS_SCRIPT" ]]; then
    "$REPORT_RUNS_SCRIPT" --date "$(date +%F)" >/dev/null 2>&1 || true
  fi

  no_tasks_detected=0
  guidance_detected=0
  if [[ $exit_code -eq 0 ]]; then
    total_ok=$((total_ok + 1))
    status="$MSG_RUN_DONE"
    if tail -n 120 "$log_file" | grep -Eq "^[[:space:]]*${MSG_NO_TASKS_PATTERN}[[:space:]]*$"; then
      status="$MSG_IDLE"
      no_tasks_detected=1
    elif tail -n 400 "$log_file" | grep -Eqi "need.*(decision|your decision)|how would you like to proceed|Potrzebuję decyzji"; then
      status="$MSG_NEEDS_DECISION"
      guidance_detected=1
    elif [[ "$todo_before" != "$todo_after" || "$done_before" != "$done_after" || "$archive_before" != "$archive_after" ]]; then
      status="$MSG_TASK_DONE"
    fi
    if [[ $no_tasks_detected -eq 1 ]]; then
      echo "[$(date +'%F %T')] run #$run_count $MSG_NO_TASKS_WAIT ${IDLE_SLEEP_SECONDS}s $MSG_NO_TASKS_WAIT_SUFFIX ($reasoning_tag)"
    elif [[ $guidance_detected -eq 1 ]]; then
      echo "[$(date +'%F %T')] $MSG_DECISION_CONTINUE ($reasoning_tag)"
    else
      echo "[$(date +'%F %T')] $status ($reasoning_tag)"
    fi
    echo "[$(date +'%F %T')] run #$run_count test_seconds=$test_seconds failure_class=$failure_class ($reasoning_tag)"
    notify normal "Run #$run_count: $status"
  else
    total_fail=$((total_fail + 1))
    echo "[$(date +'%F %T')] $MSG_ERROR: run #$run_count exit=$exit_code class=$failure_class (log: $log_file) ($reasoning_tag)"
    echo "[$(date +'%F %T')] run #$run_count test_seconds=$test_seconds failure_class=$failure_class ($reasoning_tag)"
    tail -n 40 "$log_file" || true
    notify critical "Run #$run_count $MSG_FAILED (exit $exit_code)"
  fi

  if [[ "$RALPH_MODE" == "single" ]]; then
    if [[ $no_tasks_detected -eq 1 || $guidance_detected -eq 1 ]]; then
      [[ -f "$STOP_FILE" ]] && {
        push_pending_commits
        echo "Stop file detected."
        exit 0
      }
      [[ -f "$SAFE_STOP_FILE" ]] && {
        push_pending_commits
        echo "Safe-stop file detected."
        exit 0
      }
      if [[ $no_tasks_detected -eq 1 ]]; then
        push_pending_commits
      fi
      sleep_with_dots "$IDLE_SLEEP_SECONDS"
      continue
    fi
    push_pending_commits
    echo "[$(date +'%F %T')] $MSG_SINGLE_STOPPED"
    exit "$exit_code"
  fi

  [[ -f "$SAFE_STOP_FILE" ]] && {
    push_pending_commits
    echo "Safe-stop file detected."
    exit 0
  }
  [[ -f "$STOP_FILE" ]] && {
    push_pending_commits
    echo "Stop file detected."
    exit 0
  }
  restart_self_if_requested
  if [[ $guidance_detected -eq 1 ]]; then
    sleep 1
  elif [[ $no_tasks_detected -eq 1 ]]; then
    push_pending_commits
    sleep_with_dots "$IDLE_SLEEP_SECONDS"
  elif [[ $exit_code -ne 0 ]]; then
    sleep_with_dots "$ERROR_SLEEP_SECONDS"
  else
    sleep "$SLEEP_SECONDS"
  fi
done
